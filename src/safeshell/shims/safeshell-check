#!/usr/bin/env bash
# SafeShell Fast Check - Lightweight daemon client (no Python!)
#
# This script evaluates a command against the SafeShell daemon using
# pure bash + basic Unix tools. It avoids Python startup overhead entirely.
#
# Usage: safeshell-check "command to evaluate"
# Exit: 0 = allowed, 1 = denied, 2 = error

set -euo pipefail

SOCKET="${SAFESHELL_SOCKET:-$HOME/.safeshell/daemon.sock}"
COMMAND="${1:-}"
WORKING_DIR="${2:-$(pwd)}"

if [[ -z "$COMMAND" ]]; then
    echo "[SafeShell] Error: No command provided" >&2
    exit 2
fi

# Check if socket exists
if [[ ! -S "$SOCKET" ]]; then
    # Daemon not running - fail open
    exit 0
fi

# Build JSON request (simple string escaping)
# Escape backslashes and quotes for JSON
escape_json() {
    local s="$1"
    s="${s//\\/\\\\}"  # Escape backslashes first
    s="${s//\"/\\\"}"  # Escape quotes
    s="${s//$'\n'/\\n}" # Escape newlines
    s="${s//$'\r'/\\r}" # Escape carriage returns
    s="${s//$'\t'/\\t}" # Escape tabs
    echo "$s"
}

CMD_ESCAPED=$(escape_json "$COMMAND")
DIR_ESCAPED=$(escape_json "$WORKING_DIR")

REQUEST="{\"type\":\"evaluate\",\"command\":\"${CMD_ESCAPED}\",\"working_dir\":\"${DIR_ESCAPED}\",\"env\":{},\"execution_context\":\"human\"}"

# Send request and get response using timeout + nc/socat
# Try socat first (better Unix socket support), fall back to nc
send_request() {
    if command -v socat &>/dev/null; then
        echo "$REQUEST" | socat -t 5 - "UNIX-CONNECT:$SOCKET" 2>/dev/null
    elif command -v nc &>/dev/null; then
        # BSD nc uses -U for Unix sockets
        echo "$REQUEST" | timeout 5 nc -U "$SOCKET" 2>/dev/null
    else
        # No suitable tool - fail open
        echo '{"should_execute":true}'
    fi
}

RESPONSE=$(send_request)

if [[ -z "$RESPONSE" ]]; then
    # Empty response - daemon issue, fail open
    exit 0
fi

# Parse response - look for should_execute field
# Handle potential intermediate "waiting" messages by reading the last complete response
FINAL_RESPONSE=$(echo "$RESPONSE" | tail -1)

# Extract should_execute value (simple grep-based parsing)
if echo "$FINAL_RESPONSE" | grep -q '"should_execute"[[:space:]]*:[[:space:]]*true'; then
    exit 0
elif echo "$FINAL_RESPONSE" | grep -q '"should_execute"[[:space:]]*:[[:space:]]*false'; then
    # Extract denial message if present
    DENIAL_MSG=$(echo "$FINAL_RESPONSE" | grep -oP '"denial_message"\s*:\s*"\K[^"]*' 2>/dev/null || true)
    if [[ -n "$DENIAL_MSG" ]]; then
        echo "[SafeShell] $DENIAL_MSG" >&2
    else
        echo "[SafeShell] Command blocked by policy" >&2
    fi
    exit 1
else
    # Can't parse response - fail open
    exit 0
fi
