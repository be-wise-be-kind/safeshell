#!/usr/bin/env bash
# SafeShell Universal Shim
# All command shims symlink to this script.
# It intercepts commands, checks with daemon, and executes if allowed.

# Get the command name from how we were invoked
CMD_NAME=$(basename "$0")

# Skip shim processing for hook-protected AI tools (they already validated)
# This prevents double-approval issues with Claude Code, etc.
if [[ -n "$CLAUDECODE" ]]; then
    # Find and exec the real command directly
    SHIM_DIR=$(dirname "$(readlink -f "$0")")
    IFS=':' read -ra PATH_DIRS <<< "$PATH"
    for dir in "${PATH_DIRS[@]}"; do
        [[ "$dir" == "$SHIM_DIR" ]] && continue
        if [[ -x "$dir/$CMD_NAME" ]]; then
            exec "$dir/$CMD_NAME" "$@"
        fi
    done
    echo "[SafeShell] Error: Could not find real '$CMD_NAME' in PATH" >&2
    exit 127
fi

# Find the real command (skip our shim directory in PATH)
SHIM_DIR=$(dirname "$(readlink -f "$0")")
REAL_CMD=""

# Search PATH for the real command, skipping our shim directory
IFS=':' read -ra PATH_DIRS <<< "$PATH"
for dir in "${PATH_DIRS[@]}"; do
    # Skip our shim directory
    [[ "$dir" == "$SHIM_DIR" ]] && continue

    if [[ -x "$dir/$CMD_NAME" ]]; then
        REAL_CMD="$dir/$CMD_NAME"
        break
    fi
done

if [[ -z "$REAL_CMD" ]]; then
    echo "[SafeShell] Error: Could not find real '$CMD_NAME' in PATH" >&2
    exit 127
fi

# Quick check: is daemon socket present? If not, fail-open
SOCKET="${SAFESHELL_SOCKET:-$HOME/.safeshell/daemon.sock}"
if [[ ! -S "$SOCKET" ]]; then
    exec "$REAL_CMD" "$@"
fi

# Build the full command string with RESOLVED PATH for evaluation
# This prevents recursion when daemon executes via shell
FULL_CMD="$REAL_CMD"
for arg in "$@"; do
    # Quote arguments that contain spaces or special chars
    if [[ "$arg" =~ [[:space:]] || "$arg" =~ [\'\"\$\`\\] ]]; then
        FULL_CMD="$FULL_CMD \"$arg\""
    else
        FULL_CMD="$FULL_CMD $arg"
    fi
done

# Find safeshell-check script
SAFESHELL_CHECK=""

# Check same directory as this script first
SCRIPT_DIR=$(dirname "$(readlink -f "$0")")
if [[ -x "$SCRIPT_DIR/safeshell-check" ]]; then
    SAFESHELL_CHECK="$SCRIPT_DIR/safeshell-check"
# Then check if in PATH
elif command -v safeshell-check &>/dev/null; then
    SAFESHELL_CHECK=$(command -v safeshell-check)
# Check common install locations
elif [[ -x "$HOME/.local/bin/safeshell-check" ]]; then
    SAFESHELL_CHECK="$HOME/.local/bin/safeshell-check"
fi

# If safeshell-check not found, fall back to just executing (fail-open)
if [[ -z "$SAFESHELL_CHECK" ]]; then
    exec "$REAL_CMD" "$@"
fi

# Use daemon-based execution (no Python startup!)
# safeshell-check -e sends execute request to daemon
"$SAFESHELL_CHECK" -e "$FULL_CMD"
exit $?
